/**
  * Flip Multimedia Component Managment Framework
  * used to get and apply actions to elements as and
  * when they are rendered.

  * @author James Gibbons
  * @author Flip Multimedia
  * @version 1.0
*/

/**
  * Check that JQuery has been loaded.
*/
if(typeof $ == 'undefined'){
  throw "[Flip Component Framework] requires JQuery";
}
else{
  $(function(){
    console.log('[Flip Component Framework] Loaded @ ' + new Date());
  })
}


/** 
 * Setup the message listener to handle messages being
 * sent from the designer, to display the live website
 * data, before the user saves it through the designer
 * 
 */
window.addEventListener('message', (event) => {
  switch(event.data.eventType) {
    case('componentUpdated'):
      Designer.updatePrototype(event.data.component);
    break;

    case('dynamicComponentUpdated'):
      Designer.updateDynamicPrototype(event.data);
    break;

    case('initColourPallet'):
      Designer.generateInitalColourPallet();
    break;

    case('previewMouseHoverOver'): 
      Designer.previewHover();
    break;

    case('previewMouseHoverOut'):
      Designer.previewHoverOut();
    break;
  }

}, false);

window.addEventListener('DOMContentLoaded', () => {

  const componentWrappers = document.querySelectorAll('[data-type="componentSection"]');
  for(let sectionIndex = 0; sectionIndex < componentWrappers.length; sectionIndex++) {
    const component = componentWrappers[sectionIndex];
    const theSectionIndex = sectionIndex;

    // setup click listener on block layouts
    if(component.getAttribute('data-layout') === 'blockLayout') {
      component.addEventListener('click', (event) => {
        const childComponent = component.querySelector('[data-type="blockLayoutComponent"]');

        window.parent.postMessage({
          eventType: 'dynamicBlockComponentSelect',

          sectionIndex: childComponent.getAttribute('data-section-index'),
          containerIndex: childComponent.getAttribute('data-container-index')
        }, '*');
      })
    }

    const componentWrapperElements = component.querySelectorAll('[data-type="component"]');
    for(let theComp of componentWrapperElements) {
      theComp.addEventListener('mouseenter', () => {
        let sectionIndex = theComp.parentNode.getAttribute('data-section-index');
        let containerIndex = theComp.parentNode.getAttribute('data-container-index');
        let colIndex = theComp.parentNode.getAttribute('data-col-index');

        const actionBar = document.createElement('div');
        actionBar.className = 'action-bar';
        actionBar.innerHTML = `
          <div class='action-bar' 
            <span class='action-icon'>
              <i onclick='Designer.changeDynamicComponenType("${theSectionIndex}", ${containerIndex}, ${colIndex})' class='fa fa-edit'></i>
              <i class='fa fa-eyedropper'></i>
            </span>
        </div>
        `;

        // // push to left if single col row with no margin / padding.
        // if(component.querySelectorAll('[data-type="component"]').length == 1) {
        //   actionBar.innerHTML = `
        //   <div class='action-bar section-action-bar' 
        //     <span class='action-icon'>
        //       <i <i onclick='Designer.saveSectionComponentPositionChanges(${theSectionIndex},"homepage")' class='fa fa-save'></i>
        //       <i onclick='Designer.removeSection(${theSectionIndex}, "homepage")' class='fa fa-trash'></i>
        //       <i onclick='Designer.displaySectionColourSelector(this)' class='fa fa-eyedropper'></i>
        //       <i class='fa fa-chevron-up'></i>
        //       <i class='fa fa-chevron-down'></i>
              
        //       <i onclick='Designer.changeDynamicComponenType("${theSectionIndex}", ${containerIndex}, ${colIndex})' class='fa fa-edit'></i>
        //       <i class='fa fa-eyedropper'></i>
        //     </span>
        //   </div>
        //   `;
        // }

        // hide the sub option action bar for now.
        //theComp.appendChild(actionBar);
      })
      theComp.addEventListener('mouseleave', () => {
        if(theComp.querySelectorAll('.action-bar').length > 0) {
          theComp.removeChild(theComp.querySelector('.action-bar'));
        }
      });
    }

    const componentElements = component.querySelectorAll('[data-type="component"] > div, img');
    for(let theComp of componentElements) {


      // Check that the component is draggable.
      if(theComp.closest('[data-type="component"]').getAttribute('data-drag') !== 'no-drag') {
        theComp.parentNode.style.overflow = 'hidden';
        // img.parentNode.style.position = "absolute";
        theComp.parentNode.style.height = component.style.minHeight;
  
        $(theComp).draggable();
        $(theComp).on('mouseup', (event) => {
          $(theComp).position();
  
          component.setAttribute('data-pending-save', 'true');
          const selectOptions = component.querySelector('.section-options');
          selectOptions.innerHTML = `
            <div class='action-bar section-action-bar' 
              <span class='action-icon'>
                <i <i onclick='Designer.saveSectionComponentPositionChanges(${sectionIndex},"homepage")' class='fa fa-save'></i>
                <i onclick='Designer.removeSection(${sectionIndex}, "homepage")' class='fa fa-trash'></i>
                <i onclick='Designer.displaySectionColourSelector(this)' class='fa fa-eyedropper'></i>
                <i class='fa fa-chevron-up'></i>
                <i class='fa fa-chevron-down'></i>
              </span>
            </div>
          `;
        })
  
        /** 
         * Display the position guides.
         */
        theComp.addEventListener('mouseenter', () => {
  
          theComp.parentNode.style.backgroundImage = 'url(/template-global/flip-component-framework/graphics/grid.svg)';
          theComp.parentNode.style.backgroundSize = "100% 100%";
        });
        theComp.addEventListener('mouseleave', () => {
          theComp.parentNode.style.background = 'none';
        })
  
        /** 
         * Display the alignment guides.
         */
        // theComp.addEventListener('mousedown', () => {
        //   document.addEventListener('mousemove', () => {
        //     const offset = $(theComp).offset();
  
        //     if(theComp.nextElementSibling) {
        //       const nextOffset = $(theComp.nextElementSibling).offset();
        //       console.log(nextOffset.left);
  
        //       if(nextOffset.left == offset.left || nextOffset.left == offset.left + 25) {
                
        //         console.log($(theComp.nextElementSibling).position());
  
        //         // Display the alignment guide.
        //         const guide = document.createElement('div');
        //         guide.classList.add('guide');
        //         guide.classList.add('guide-x');
        //         guide.style.left = nextOffset.left;
  
        //         console.log('guide - x ');
  
        //         // render guide.
        //         theComp.parentNode.appendChild(guide);
        //       }
        //     }
        //   });
        // });
        // theComp.addEventListener('mouseup', () => {
        //   if(theComp.parentNode.querySelectorAll('.guide')) {
        //     for(let guide of theComp.parentNode.querySelectorAll('.guide')) {
        //       theComp.parentNode.removeChild(guide);
        //     }
        //   }
        // });
  
        // // Setup the drag event.
        // img.setAttribute('draggable', 'true');
        // img.ondragstart = Designer.imageDragEvent;
      }
    }  

    component.addEventListener('mouseenter', (event) => {
      var e = event.toElement || event.relatedTarget;
      if (e && e.parentNode == this || e == this) {
        event.preventDefault();
      }
      
      const sectionOptions = document.createElement('div');
      sectionOptions.classList.add('section-options');
      sectionOptions.id = 'options';

      // Get height of the component for options
      sectionOptions.style.height = component.offsetHeight;
      sectionOptions.style.top = component.offsetTop;

      let saveIcon = '';
      if(component.getAttribute('data-pending-save') == 'true') {
        saveIcon = `<i onclick='Designer.saveSectionComponentPositionChanges(${sectionIndex},"homepage")' class='fa fa-save'></i>`;
      }

      // render the action bar
      sectionOptions.innerHTML = `
        <div class='action-bar' 
          <span class='action-icon'>
            ${saveIcon}
            <i onclick='Designer.removeSection(${sectionIndex}, "homepage")' class='fa fa-trash'></i>
            <i onclick='Designer.displaySectionColourSelector(this)' class='fa fa-eyedropper'></i>
            <i class='fa fa-chevron-up'></i>
            <i class='fa fa-chevron-down'></i>
          </span>
        </div>
      `;

      console.log(component); 

      // add sections options to the parent section class.
      component.appendChild(sectionOptions);

      // Display the borders to the child components.
      const dynamicComponents = component.getElementsByClassName('component-dynamic');
      for(let theComponent of dynamicComponents) {

        theComponent.querySelector('div, img').addEventListener('click', (event) => {
          
          // Load the parent component to get the GRID layout path to this component.
          const parentComponent = theComponent.parentNode;

          window.parent.postMessage({
            eventType: 'dynamicComponentSelected',

            sectionIndex: parentComponent.getAttribute('data-section-index'),
            containerIndex: parentComponent.getAttribute('data-container-index'),
            colIndex: parentComponent.getAttribute('data-col-index')
          }, '*');
        })

        // add the hover class to the child components.
        theComponent.classList.add('hover');
      }
    });


    component.addEventListener('mouseleave', (event) => {
      component.removeChild(document.getElementById('options'));

      // Remove the borders to the child components.
      const dynamicComponents = component.getElementsByClassName('component-dynamic');
      for(let theComponent of dynamicComponents) {

        // remove the hover class to the child components.
        theComponent.classList.remove('hover');
      }
    });

    // const componentLayoutSections = document.querySelectorAll('[data-type="componentSection"]');
    // for(let section of componentLayoutSections) {

    //   section.addEventListener('mouseover', (event) => {
    //     const compElement = event.target;

    //     // append the border.
    //     compElement.style.borderColour = "red";
    //     compElement.style.borderWidth = "2px";
    //     compElement.style.borderStyle = "solid";

    //   }, false);

    //   section.addEventListener('mouseout', (event) =>  {
    //     event.target.style.borderStyle = 'none';
    //   })

    //   // the component layout is an instance of GridLayout
    //   if(section.attributes['data-layout'] === 'gridLayout') {
      
    //   }
    // }
  }
});

/** 
 * Function used to load a style from the computed
 * styles functionality that is built into HTML5, 
 * and return the background colour in the form of
 * either RGB or HEX Code.
 * 
 * By default, we will return a hex code if there is
 * no defined background colour.
 * 
 * @param {HtmlDOMElement} element The element to grab styles from.
 * @param {String} style The style to get from element.
 * 
 * @returns {String} The colour HEX code.
 * 
 */
function getBackgroundColour(element) {
  const rgbColourCode = window.getComputedStyle(element, null).getPropertyValue('background-color');
  if(rgbColourCode) {
    return rgbColourCode;
  }
  else {
    return '#ccccc';
  }
}

/** 
 * Function used to load a style from the computed
 * styles functionality that is built into HTML5, 
 * and return the text colour in the form of
 * either RGB or HEX Code.
 * 
 * By default, we will return a hex code if there is
 * no defined text colour.
 * 
 * @param {HtmlDOMElement} element The element to grab styles from.
 * @param {String} style The style to get from element.
 * 
 * @returns {String} The colour HEX code.
 * 
 */
function getTextColour(element) {
  const rgbColourCode = window.getComputedStyle(element, null).getPropertyValue('color');
  if(rgbColourCode) {
    return rgbColourCode;
  }
  else {
    return '#ccccc';
  }
}

const Designer = {
  selectComponent: function(selectComponent) {
    console.log('--');

    window.parent.postMessage({
      eventType: 'componentSelected',
      componentId: selectComponent.target.id
    
    }, '*');

    // parent.designerSelectElement(selectComponent.target.id);
  },

  selectDynamicComponent: function(selectedComponent) {

  },

  /** 
   * Function called when the delete section icon is
   * clicked.
   * 
   */
  removeSection: function(sectionId, sectionParent) {
    window.parent.postMessage({
      eventType: 'removeSection',
      sectionIndex: sectionId,
      sectionParent: sectionParent
    }, '*');
  },

  /** 
   * Function called when a component section is clicked.
   * 
   */
  previewHover: function() {
    const componentSections = document.querySelectorAll('[data-type="componentSection"]');
    for(let section of componentSections) {

      // create the add section button.
      const addSection = document.createElement('div');
      addSection.classList.add('add-section');
      addSection.innerHTML = '<i class="fa fa-plus" aria-hidden="true"></i>';

      // handle the add section click event
      addSection.addEventListener('click', () => {
        console.log('clicked.');
        window.parent.postMessage({
          eventType: 'addSectionClick',
          lastSection: section.getAttribute('data-section')
        }, '*');
      });

      section.appendChild(addSection);
    }
  },

  previewHoverOut: function() {
    const componentSections = document.querySelectorAll('[data-type="componentSection"]');
    for(let section of componentSections) {

      // remove the add section button.
      if(section.contains(section.querySelector('.add-section'))) {
        section.removeChild(section.querySelector('.add-section'));
      }
    }
  },

  displaySectionColourSelector: function(eventElement) {
    window.parent.postMessage({
      eventType: 'getColourPallet'
    }, '*');
    window.addEventListener('message', (event) => {
      if(event.data.eventType === 'receiveColourPallet') {
        const colourPallet = event.data.primaryColourPallet;

        const componentElement = eventElement.parentNode.parentNode.parentNode;
        const actionBar = eventElement.parentNode;

        const colourSelector = document.createElement('div');
        colourSelector.className = 'colour-selector';

        for(let palletColour in colourPallet) {
          const colourCode = colourPallet[palletColour].colour;

          const colour = document.createElement('div');
          colour.style.backgroundColor = colourCode;
          colour.className = 'colour';

          colour.addEventListener('click', (event) => { 
            componentElement.style.backgroundColor = colourCode;

            // save changes.
            window.parent.postMessage({
              eventType: 'updateSectionColour',
              sectionIndex: componentElement.getAttribute('data-section-index'),
              sectionId: componentElement.getAttribute('data-section-id'),
              colourCode: colourCode
            }, '*');
          });
      
          colourSelector.appendChild(colour);
        }
        
        actionBar.appendChild(colourSelector);
      }
    });
  },

  changeDynamicComponenType: function(sectionIndex, containerIndex, colIndex) {
    window.parent.postMessage({
      eventType: 'dynamicComponentTypeChange',

      sectionIndex: sectionIndex,
      containerIndex: containerIndex,
      colIndex: colIndex
    }, '*');
  },

  updateDynamicPrototype: function(eventData) {
    let querySelectorString = `div[data-section-index="${eventData.sectionIndex}"]`;
    querySelectorString += `[data-container-index="${eventData.containerIndex}"]`;

    // if the component is within a grid layout, there will also be a col index provided.e
    if(eventData.colIndex) {
      querySelectorString += `[data-col-index="${eventData.colIndex}"`;
    }

    console.log('Parent element = ');
    const componentParentElement = document.querySelector(querySelectorString);
    
    // update the component HTML code for preview.
    componentParentElement.innerHTML = eventData.componentHTML;

    // /**
    //  * Since the col index is is only passed from components that are within a grid
    //  * layout, we need to emit this from block layouts, as this will cause result
    //  * in the element not being found by the query selector.
    //  */
    // if(eventData.colIndex && typeof eventData.colIndex !== 'undefined' ) {
    //   querySelectorString += `[data-col-index="${eventData.colIndex}"]`; 
    // }

    // console.log(eventData);

    // const componentParentElement = document.querySelector(querySelectorString);
    // const componentElement = componentParentElement.querySelector('[data-type="component"]');

    // // console.log(componentElement);
    // console.log(eventData.component);

    // if(componentElement.getAttribute('data-component-type') === 'textBlockComponent') {
    //   componentElement.querySelector('[data-attribute="title"]').innerHTML = eventData.component.title;
    //   componentElement.querySelector('[data-attribute="subTitle"]').innerHTML = eventData.component.subTitle;
    //   componentElement.querySelector('[data-attribute="body"]').innerHTML = eventData.component.body;
    // }

    // if(componentElement.getAttribute('data-component-type') === 'cardComponent') {
    //   componentElement.querySelector('[data-attribute="title"]').innerHTML = eventData.component.title;
    //   componentElement.querySelector('[data-attribute="body"]').innerHTML = eventData.component.body;
    // }

    // if(componentElement.getAttribute('data-component-type') === 'imageComponent') {
    //   componentElement.querySelector('img').style.width = eventData.component.width;
    // }

    // if(componentElement.getAttribute('data-component-type') === 'spacerComponent') {}

    // if(componentElement.getAttribute('data-component-type') === 'bannerComponent') {
    //   componentElement.querySelector('[data-attribute="title"]').innerHTML = eventData.component.title;
    // }

    // for(let style in eventData.component.styles) {
    //   if(typeof eventData.component.styles[style] == 'string') {

    //     // images must be selected on their own.
    //     if(componentElement.getAttribute('data-component-type') === 'imageComponent') {
    //       componentElement.querySelector('img').style[style] = eventData.component.styles[style];
    //     }
    //     else {
    //       componentElement.style[style] = eventData.component.styles[style];
    //     }
    //   }
    //   else {
    //     for(let subStyle in eventData.component.styles[style]) {
    //       if(componentElement.getAttribute('data-component-type') === 'imageComponent') {
    //         componentElement.querySelector('img').style[subStyle] = eventData.component.styles[style][subStyle];
    //       }
    //       else {
    //         componentElement.style[subStyle] = eventData.component.styles[style][subStyle];
    //       }
    //     }
    //   }
    // }
  },

  /** 
   * Function called when the designer has sent some 
   * data to preview on the site; This is only for testing
   * changes that the user makes, before they are saved on
   * the backend, through the designer.
   * 
   */
  updatePrototype: function(component) {
    if(document.getElementById(component.name)) {
      let element = document.getElementById(component.name); 
      
      // Update the content of the component to the new content
      if(component.type === 'text') {
        element.innerHTML = component.value;
      }
      else if(component.type === 'image') {
        element.getElementsByTagName('img')[0].src = component.value;
      }

      // Update the styles of the element.
      if(component.styles.fontColour) {
        element.style.color = component.styles.fontColour;
      }

      // Update the styles of the element.
      if(component.styles.border) {
        let borderStyle = "";
        if(component.styles.borderWidth) {
          borderStyle = borderWidth;
        }
        
        borderStyle += ' solid ';

        if(component.styles.borderColour) {
          borderStyle+= component.styles.borderColour;
        }

        document.getElementById(component.name).style.border = borderStyle;
      }

      // Update the border radius
      if(component.styles.borderRadius) {
        if(component.type === 'image') {
          element.getElementsByTagName('img')[0].style.borderRadius = component.styles.borderRadius;
        }
        
        element.style.borderRadius = component.styles.borderRadius;
      }

      if(component.styles.width) {
        if(component.type === 'image') {
          element.getElementsByTagName('img')[0].style.width = component.styles.width;
        }

        element.style.width = component.styles.width;
      }
    }
    else {
      console.error('Cannot prototype (preview) invalid component name.');
    }
  },

  saveSectionComponentPositionChanges: function(sectionIndex, sectionName) {
   const section = document.querySelectorAll('[data-type="componentSection"]')[sectionIndex];
   for(let component of section.querySelectorAll('[data-type="component"]')) {
    const colParent = component.parentNode;

    let top = null;
    let left = null;

    if(component.querySelector('img, div').style.top) {
      top = component.querySelector('img, div').style.top;
    }
    else {
      if(component.querySelector('img, div').style.marginTop) {
        top = component.querySelector('img, div').style.marginTop;
      }
      else {
        top = window.getComputedStyle(component.querySelector('img, div')).marginTop;
      }
    }

    if(component.querySelector('img, div').style.left) {
      left = component.querySelector('img, div').style.left;
    }
    else {
      if(component.querySelector('img, div').style.marginLeft) {
        left = component.querySelector('img, div').style.marginLeft;
      }
      else {
        left = window.getComputedStyle(component.querySelector('img, div')).marginLeft;
      }
    }
    
    console.log(component.querySelector('img, div').style.top);
    console.log(`${left}, ${top}`);

    window.parent.postMessage({
        eventType: 'componentPositionChange',
        
        top: top,
        left: left,

        sectionIndex: colParent.getAttribute('data-section-index'),
        containerIndex: colParent.getAttribute('data-container-index'),
        colIndex: colParent.getAttribute('data-col-index')

      }, '*');
   }
  },

  /** 
   * Function used to load the colour scheme from the website,
   * and send it back to the backend service.
   * 
  */
  generateInitalColourPallet: function() {

    console.log('color = ' + getBackgroundColour(document.getElementsByTagName('body')[0]));

    let colourPallet = {
      primarybackground: {
        name: 'Primary Background',
        colour: getBackgroundColour(document.getElementsByTagName('body')[0])
      },
      secondaryBackground: {
        name: 'Secondary Background',
        colour: getBackgroundColour(document.getElementsByClassName('services')[0])
      },
      navbarBackground: {
        name: 'Navbar Background',
        colour: getBackgroundColour(document.getElementsByTagName('nav')[0])
      },

      textDefault: {
       name: 'Text Default',
       colour: getTextColour(document.getElementsByTagName('p')[0]) 
      },
      textHeader: {
        name: 'Header Text',
        colour: getTextColour(document.getElementsByTagName('h2')[0])
      },
      textBanner: {
        name: 'Background Text',
        colour: getTextColour(document.querySelector('.banner h1'))
      }
    };

    // Send the generated colour pallet back to the designer backend.
    window.parent.postMessage({
      eventType: 'palletGenerated',
      colourPallet: colourPallet

    }, '*');
  }
}